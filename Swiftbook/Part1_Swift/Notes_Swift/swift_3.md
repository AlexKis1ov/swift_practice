<!-- Урок 3. Условные инструкции. Опциональные типы данных -->

- [Условные конструкции](#условные-конструкции)
  - [Конструкция if](#конструкция-if)
  - [Конструкция if-else](#конструкция-if-else)
  - [Тренарный оператор](#тренарный-оператор)
  - [Switch](#switch)
- [Опциональные типы данных](#опциональные-типы-данных)
    - [Объявление опционального типа:](#объявление-опционального-типа)
    - [Извлечение опционалов](#извлечение-опционалов)
    - [Принудительное извлечение опционалов](#принудительное-извлечение-опционалов)
    - [Привязка опционалов](#привязка-опционалов)
    - [Оператор объединения с nil (nil coalescing)](#оператор-объединения-с-nil-nil-coalescing)
    - [Неявно извлеченные опционалы](#неявно-извлеченные-опционалы)
---
# Условные конструкции

## Конструкция if 
*Общий вид*
```swift
if condition {
    // some code
}
```

❗️ CTRL + I позволяет корректно выставлять табуляции, если код поехал

## Конструкция if-else
```swift
if condition {
    // code
} else {
    // code
}
```
Если условие не подходит под `if`, то выполняется блок `else`

❗️ Не стоит всегда создавать конечный else, ставить его стоит в том случае, если он нужен

Вместо нескольких if можно условия писать через запятую
```swift
if 1 < 2 {
    if 2 < 3 {
        print(true) // true
    }
}

if 1 < 2, 2 < 3 {
    print(true) // true
}
```

## Тренарный оператор 
*Общий вид*
```swift
condition ? trueCondition : falseCondition
```

*Пример* 
```swift
let a = 5
let b = 10

a < 10 ? print("The condition is true") : print("The condition is false") // "The condition is true"

c = a < 10 ? a - b : a + b // -5
```
❗️ Тернарый оператор можно использовать, если в условных блоках 1 строка кода

## Switch

❗️ В свифт кейс default должен быть определен по умолчанию (без него нельзя)

```
switch значение для сопоставления {
case значение 1:
    инструкция для первого значения
case значение 2, значение 3:
    инструкция для второго и третьего значения
default:
    инструкция, если совпадений с шаблонами не найдено
}
```

*Пример*
```swift
var someCharacter: Character = "a"

switch someCharacter {
case "a", "A":
    print("Is an A") // Is an A
case "b", "B":
    print("Is an B") // не выполняется
case "c", "C":
    print("Is an C") // не выполняется
default:
    print("Don't know what is it") // не выполняется
}
```

Соответсвие диапазону
```swift
let approximateCount = 62
let countedThings = "moons orbiting Saturn"
var naturalCount = ""

switch approximateCount {
case ..<0:
    print("Error")
case 0:
    naturalCount = "zero"
case 1:
    naturalCount = "one"
case 2..<5:
    naturalCount = "a few"
case 5...11:
    naturalCount = "several"
case 12...99:
    naturalCount = "dozens of"
default:
    naturalCount = "many"
}

print("There are \(naturalCount) \(countedThings)") // naturalCount =  dozens of
```

# Опциональные типы данных

Опционалы так же нужны, при работе с сетью. Опциональный тип позвоялет перестраховаться, что данные получены из сети и вывести их, а в случае ошибки получения данных из сети, опциональный тип позволяет получить `nil`

❗️ Все элементы в юзеринтерфейсе - всегда опциональны

Так как опционалы могуть иметь или не иметь значение, это накладывает на разработчика обязанность извлечения опционального значения. Нужно точно есть, есть ли значение в свойстве или нет.

### Объявление опционального типа:
```swift
let someString = ""
let anotherString: String
var optionalString: String? = ""
```

Любой опицональный тип может иметь значение своего типа, так и `nil`

```swift
var value: Int? = 19
value = nil
value = 10
```

### Извлечение опционалов
```swift
let possibleNumber = "12345s"
var convertedNumber = Int(possibleNumber) // вернет nil, так как привести к Int строку не удалось

// Проверка наличия опционала
if convertedNumber == nil {
    print("convertedNumber does not contains some integer value")
}
```

### Принудительное извлечение опционалов
Если принудительно извлечь значение опционала, который является `nil` - произойдет фатальная ошибка
```swift
var opt: Int? = 10
print(opt!) // 10

opt = nil
print(opt!) // !fatal error
```
❗️ Принудительно извлекать значения в проектах СТРОГО запрещено, нужно использовать привязку или nil coalescing

### Привязка опционалов
Привязка позволяет создать константу с обычным типом из опционального типа
```swift
var convertedNumber: Int? = 16

if let convertedNumber = convertedNumber {
    print(convertedNumber) // 16
} else {
    print("is nil")
}
```

### Оператор объединения с nil (nil coalescing)
С помощью оператора ?? (называемого оператором объединения с nil) возвращается либо значение опционала, либо значение по умолчанию (если опционал равен nil)

```swift
var opt: Int? = nil
print(opt ?? 0) // выводит 0
```

### Неявно извлеченные опционалы
Когда проектируется интерфейс - все элементы интерфейса опциональные, но при этом, один раз проинициализировав все свойства (все элементы ui) они больше не могут принимать nil, пока экран с элементами активен

Зная, что значение больше НЕ МОЖЕТ быть `nil`, можно неявно извлечь опционал 

```swift
var name = ""
// элемент интерфейса - userName
var userName: String! = "Tim Cook"

name = userName
```
